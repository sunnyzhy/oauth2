# 表结构说明

## 授权服务相关的表

### oauth_client_details

|字段|描述|
|--|--|
|client_id|主键，必须唯一。在实际应用中也可以称为 clientId， appId， appKey 等。|
|resource_ids|客户端所能访问的资源 id 集合，多个资源时用逗号(，)分隔，如: "user,log"。|
|client_secret|用于指定客户端(client)的访问密匙，必须是加密过的密文。在实际应用中也可以称为 appSecret 等。|
|scope|用于指定客户端的授权范围，可自定义，如: read, write, trust 等，多个授权范围之间用逗号(，)分隔，如: "read,write"。|
|authorized_grant_types|授权类型，取值范围: **authorization_code, password, refresh_token, implicit, client_credentials**; 多个授权类型之间用逗号(,)分隔，如: "authorization_code,refresh_token"。|
|web_server_redirect_uri|重定向URI，当 grant_type 为 authorization_code 或 implicit 时， redirect_uri不能为空，并且 url 里设置的 redirect_uri 必须跟数据库里的 redirect_uri 一致。|
|authorities|授权的角色，多个角色之间用逗号(,)分隔， 如: "ROLE_ADMIN,ROLE_USER"。|
|access_token_validity|access_token 的有效时间(单位:秒)，默认的有效时间 = 60 * 60 * 12 = 12 小时。|
|refresh_token_validity|refresh_token 的有效时间值(单位:秒)，默认的有效时间 = 60 * 60 * 24 * 30 = 30 天。|
|additional_information|预留字段，一般用来存储 JSON 格式的数据。|
|autoapprove|autoapprove 用于跟上下文里的 scope 进行比较，如果 autoapprove 完全包含了上下文里所有的 scope, 则后台自动添加或者修改数据表 oauth_approvals, 详情请参考 [生成approve的流程](https://github.com/sunnyzhy/oauth2/blob/main/%E7%94%9F%E6%88%90approve%E7%9A%84%E6%B5%81%E7%A8%8B.md '生成approve的流程'); 该字段只适用于 grant_type="authorization_code" 的情况。|

### oauth_access_token

|字段|描述|
|--|--|
|token_id|把授权服务返回的 access_token 经过 MD5 加密之后，所生成的加密串。|
|token|把 OAuth2AccessToken 对象序列化为字节流，并封装成 SqlLobValue 类型的数据库对象。|
|authentication_id|把上下文里的 username, client_id, scope 封装成 Map, 并经过 MD5 加密之后，所生成的加密串。|
|user_name|上下文里的认证用户名|
|client_id|上下文里的client_id|
|authentication|把 OAuth2Authentication 对象序列化为字节流，并封装成 SqlLobValue 类型的数据库对象。|
|refresh_token|把授权服务返回的 refresh_token 经过 MD5 加密之后，所生成的加密串。|

- 源文件
   ```
   \org\springframework\security\oauth\spring-security-oauth2\2.3.4.RELEASE\spring-security-oauth2-2.3.4.RELEASE.jar!\org\springframework\security\oauth2\provider\token\store\JdbcTokenStore.class
   ```

- 源码
   ```java
    public void storeAccessToken(OAuth2AccessToken token, OAuth2Authentication authentication) {
        String refreshToken = null;
        if (token.getRefreshToken() != null) {
            refreshToken = token.getRefreshToken().getValue();
        }

        if (this.readAccessToken(token.getValue()) != null) {
            this.removeAccessToken(token.getValue());
        }

        this.jdbcTemplate.update(this.insertAccessTokenSql, new Object[]{this.extractTokenKey(token.getValue()), new SqlLobValue(this.serializeAccessToken(token)), this.authenticationKeyGenerator.extractKey(authentication), authentication.isClientOnly() ? null : authentication.getName(), authentication.getOAuth2Request().getClientId(), new SqlLobValue(this.serializeAuthentication(authentication)), this.extractTokenKey(refreshToken)}, new int[]{12, 2004, 12, 12, 12, 2004, 12});
    }
   ```
   - token_id: this.extractTokenKey(token.getValue()), 用 MD5 加密 access_token 所生成的 32 位加密串
   - token: new SqlLobValue(this.serializeAccessToken(token))
   - authentication_id: this.authenticationKeyGenerator.extractKey(authentication)
   - user_name: authentication.getName()
   - client_id: authentication.getOAuth2Request().getClientId()
   - authentication: new SqlLobValue(this.serializeAuthentication(authentication))
   - refresh_token: this.extractTokenKey(refreshToken)

```java
    // 用 MD5 加密原始的 token 字符串
    protected String extractTokenKey(String value) {
        if (value == null) {
            return null;
        } else {
            MessageDigest digest;
            try {
                digest = MessageDigest.getInstance("MD5");
            } catch (NoSuchAlgorithmException var5) {
                throw new IllegalStateException("MD5 algorithm not available.  Fatal (should be in the JDK).");
            }

            try {
                byte[] bytes = digest.digest(value.getBytes("UTF-8"));
                return String.format("%032x", new BigInteger(1, bytes));
            } catch (UnsupportedEncodingException var4) {
                throw new IllegalStateException("UTF-8 encoding not available.  Fatal (should be in the JDK).");
            }
        }
    }
    
    // 序列化 OAuth2AccessToken 对象
    protected byte[] serializeAccessToken(OAuth2AccessToken token) {
        return SerializationUtils.serialize(token);
    }
    
    // 把序列化之后的字节流封装成 SqlLobValue 类型的数据库对象
    public SqlLobValue(@Nullable byte[] bytes) {
        this((byte[])bytes, new DefaultLobHandler());
    }
    
    // DefaultAuthenticationKeyGenerator#extractKey
    // 1. 把 username, client_id, scope 封装进 Map
    // 2. 用 MD5 加密 Map
    public String extractKey(OAuth2Authentication authentication) {
        Map<String, String> values = new LinkedHashMap();
        OAuth2Request authorizationRequest = authentication.getOAuth2Request();
        if (!authentication.isClientOnly()) {
            values.put("username", authentication.getName());
        }

        values.put("client_id", authorizationRequest.getClientId());
        if (authorizationRequest.getScope() != null) {
            values.put("scope", OAuth2Utils.formatParameterList(new TreeSet(authorizationRequest.getScope())));
        }

        return this.generateKey(values);
    }
    
    // DefaultAuthenticationKeyGenerator#generateKey
    // 用 MD5 加密 Map
    protected String generateKey(Map<String, String> values) {
        try {
            MessageDigest digest = MessageDigest.getInstance("MD5");
            byte[] bytes = digest.digest(values.toString().getBytes("UTF-8"));
            return String.format("%032x", new BigInteger(1, bytes));
        } catch (NoSuchAlgorithmException var4) {
            throw new IllegalStateException("MD5 algorithm not available.  Fatal (should be in the JDK).", var4);
        } catch (UnsupportedEncodingException var5) {
            throw new IllegalStateException("UTF-8 encoding not available.  Fatal (should be in the JDK).", var5);
        }
    }
   ```

### oauth_refresh_token

|字段|描述|
|--|--|
|token_id|把授权服务返回的 refresh_token 经过 MD5 加密之后，所生成的加密串。|
|token|把 OAuth2RefreshToken 对象序列化为字节流，并封装成 SqlLobValue 类型的数据库对象。|
|authentication|把 OAuth2Authentication 对象序列化为字节流，并封装成 SqlLobValue 类型的数据库对象。|

- 源文件
   ```
   \org\springframework\security\oauth\spring-security-oauth2\2.3.4.RELEASE\spring-security-oauth2-2.3.4.RELEASE.jar!\org\springframework\security\oauth2\provider\token\store\JdbcTokenStore.class
   ```

- 源码
   ```java
   public void storeRefreshToken(OAuth2RefreshToken refreshToken, OAuth2Authentication authentication) {
        this.jdbcTemplate.update(this.insertRefreshTokenSql, new Object[]{this.extractTokenKey(refreshToken.getValue()), new SqlLobValue(this.serializeRefreshToken(refreshToken)), new SqlLobValue(this.serializeAuthentication(authentication))}, new int[]{12, 2004, 2004});
    }
    
    // 序列化 OAuth2RefreshToken 对象
    protected byte[] serializeRefreshToken(OAuth2RefreshToken token) {
        return SerializationUtils.serialize(token);
    }
   ```

### oauth_approvals

|字段|描述|
|--|--|
|userId|上下文里的认证用户名|
|clientId|上下文里的client_id|
|scope|oauth_client_details.scope，如果是多个 scope，则每个 scope 单独存储为 oauth_approvals 的一条记录。 |
|status|ApprovalStatus，取值范围: **APPROVED, DENIED**|
|expiresAt|Approval 的有效期。|
|lastModifiedAt|最后一次修改 Approval 的时间。同一 clientId, 同一 scope, 在添加时，实际执行的是修改操作。|

详情请参考 [生成approve的流程](https://github.com/sunnyzhy/oauth2/blob/main/%E7%94%9F%E6%88%90approve%E7%9A%84%E6%B5%81%E7%A8%8B.md '生成approve的流程')

### oauth_code

|字段|描述|
|--|--|
|code|授权服务返回的授权码。|
|authentication|把 OAuth2Authentication 对象序列化为字节流，并封装成 SqlLobValue 类型的数据库对象。|

- 源文件
   ```
   \org\springframework\security\oauth\spring-security-oauth2\2.3.4.RELEASE\spring-security-oauth2-2.3.4.RELEASE.jar!\org\springframework\security\oauth2\provider\code\JdbcAuthorizationCodeServices.class
   ```

- 源码
   ```java
   protected void store(String code, OAuth2Authentication authentication) {
        this.jdbcTemplate.update(this.insertAuthenticationSql, new Object[]{code, new SqlLobValue(SerializationUtils.serialize(authentication))}, new int[]{12, 2004});
    }
   ```

### clientdetails

1. 定制版的 oauth_client_details
2. clientdetails 的表字段含义跟 oauth_client_details 的表字段基本相同。

|字段|描述|
|--|--|
|app_id|主键，必须唯一。在实际应用中也可以称为 client_id， clientId， appKey 等。|
|resource_ids|客户端所能访问的资源 id 集合，多个资源时用逗号(，)分隔，如: "user-resource，log-resource"。|
|app_secret|用于指定客户端(client)的访问密匙，必须是加密过的密文。在实际应用中也可以称为 client_secret 等。|
|scope|用于指定客户端的授权范围，可自定义 read, write, trust 等，多个授权范围之间用逗号(，)分隔，如: "read,write"。|
|grant_types|授权类型，取值范围: **authorization_code, password, refresh_token, implicit, client_credentials**; 多个授权类型之间用逗号(,)分隔，如: "authorization_code,refresh_token"。|
|redirect_url|重定向URI，当 grant_type 为 authorization_code 或 implicit 时， redirect_uri不能为空，并且 url 里设置的 redirect_uri 必须跟数据库里的 redirect_uri 一致。|
|authorities|授权的角色，多个角色之间用逗号(,)分隔， 如: "ROLE_ADMIN,ROLE_USER"。|
|access_token_validity|access_token 的有效时间(单位:秒)，默认的有效时间 = 60 * 60 * 12 = 12小时。|
|refresh_token_validity|refresh_token 的有效时间值(单位:秒)，默认的有效时间 = 60 * 60 * 24 * 30 = 30天。|
|additional_information|预留字段，一般用来存储 JSON 格式的数据。|
|auto_approve_scopes|auto_approve_scopes 用于跟上下文里的 scope 进行比较，如果 auto_approve_scopes 完全包含了上下文里所有的 scope, 则后台自动添加或者修改数据表 oauth_approvals, 详情请参考 [生成approve的流程](https://github.com/sunnyzhy/oauth2/blob/main/%E7%94%9F%E6%88%90approve%E7%9A%84%E6%B5%81%E7%A8%8B.md '生成approve的流程'); 该字段只适用于 grant_type="authorization_code" 的情况。|

## 客户端相关的表

### oauth_client_token

|字段|描述|
|--|--|
|token_id|把授权服务返回的 access_token 经过 MD5 加密之后，所生成的加密串。|
|token|把 OAuth2AccessToken 对象序列化为字节流，并封装成 SqlLobValue 类型的数据库对象。|
|authentication_id|把上下文里的 username, client_id, scope 封装成 Map, 并经过 MD5 加密之后，所生成的加密串。|
|user_name|上下文里的认证用户名|
|client_id|上下文里的client_id|
